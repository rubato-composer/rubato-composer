/*
 * Copyright (C) 2001 Gérard Milmeister
 * Copyright (C) 2001 Stefan Müller
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of version 2 of the GNU General Public
 * License as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public
 * License along with this program; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 *
 */

////////////////////////////////////////////////////////////////////////////////
//////////////////// GENERATOR OPTIONS /////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

options {
    STATIC = false ; 
}


////////////////////////////////////////////////////////////////////////////////
//////////////////// DENOTEX PARSER CLASS //////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

PARSER_BEGIN(DenotexParser)

package org.rubato.rubettes.denotex;

import java.util.List;
import java.util.ArrayList;
import java.util.LinkedList;

import java.io.Reader;
import java.io.InputStream;
import java.io.IOException;
import java.net.URL;

import org.rubato.math.arith.*;
import org.rubato.math.module.*;
import org.rubato.math.yoneda.*;
import org.rubato.base.Repository;

public final class DenotexParser {

    // public constructors

    public DenotexParser(Reader input, Symboltable t) {
        this(input, t, Repository.systemRepository());
    }


    public DenotexParser(Reader input, Symboltable t, Repository rep) {
        this(input);
        this.t = t;
        this.url = null;
        this.rep = rep;
    }


    public DenotexParser(InputStream input, Symboltable t) {
        this(input, t, Repository.systemRepository());
    }


    public DenotexParser(InputStream input, Symboltable t, Repository rep) {
        this(input);
        this.t = t;
        this.url = null;
        this.rep = rep;
    }


    public DenotexParser(URL url, Symboltable t) 
            throws IOException {
        this(url, t, Repository.systemRepository());
    }


    public DenotexParser(URL url, Symboltable t, Repository rep) 
            throws IOException {
        this(url.openStream(), t, rep);
        this.url = url;
    }


    public void parse() throws ParseException {
        try {
            denotex();
        }
        catch(TokenMgrError e) {
            ParseException pe = parseError(e.getMessage());
            throw pe;
        }
        catch(ParseException e) {
            throw e;
        }
    }
    

    public void parselink() throws ParseException {
  		parse();
  		Linker.link(t, rep);
	}


	public void parseForm() throws ParseException {
        try {
			formDefinition();
        }
        catch(TokenMgrError e) {
            ParseException pe = parseError(e.getMessage());
            throw pe;
        }
        catch(ParseException e) {
            throw e;
        }
	}


	public void parseDenotator() throws ParseException {
        try {
			substanceDefinition();
        }
        catch(TokenMgrError e) {
            ParseException pe = parseError(e.getMessage());
            throw pe;
        }
        catch(ParseException e) {
            throw e;
        }
	}

    // other public constructors (do not use!)
    // automatically generated by java_cc:
    // DenotexParser(java.io.Reader reader) or
    // DenotexParser(java.io.InputStream stream)

    public static void main(String[] args) {
        Symboltable symtab = new Symboltable();
        try {
            DenotexParser parser = new DenotexParser(new URL(args[0]), symtab);
            parser.parse();
            System.out.println("input correctly parsed.");
            Linker.link(symtab);
            System.out.println("input linked.");
        } catch(Exception e) {
            e.printStackTrace();
        }
    }


    // parse exception generation method

    private ParseException parseError(String msg) {
        return new ParseException(msg);
    }


    private String stripQuotes(String s) {
        return s.substring(1, s.length()-1);
    }


    private void checkDelimiters(int real, int expected) throws ParseException {
        if (real != expected)
            throw parseError("Delimiters do not match type '" + Form.typeToString(expected) + "'");
    }


    private void includeFile(String path) throws ParseException {
        if (url != null) {
            // allow relative path name
            if (path.indexOf("://") == -1) {
                String s = url.toString();
                path = s.substring(0, s.lastIndexOf("/")+1) + path;
            }
        }
        DenotexParser p;
        try {
            p = new DenotexParser(new URL(path), t, rep);
        } catch(Exception e) {
            throw parseError("Malformed URL '" + path + "' (" + e.getMessage() + ")");
        }
        //System.out.println("Including file " + path);
        p.parse();
        //System.out.println("Done file " + path);
    }


    private Form defineForm(NameEntry name, int type, List crs) throws ParseException {
        if (t.forms().get(name) != null)
            throw parseError("Form '" + name + "' already defined.");

        Form form = null;
        NameDenotator n = NameDenotator.make(name);
        switch(type) {
            case Yoneda.SIMPLE: {
                try {
                    if (crs.size() == 1)
                        form = new SimpleForm(n, (Module)crs.get(0));
                    else
                        form = new SimpleForm(n, (Module)crs.get(0),
                                                      (ModuleElement)crs.get(1),
                                                      (ModuleElement)crs.get(2));
                } catch(Exception e) { throw parseError("Form build failed: " + e.getMessage()); }
                break;
            }
            case Yoneda.LIMIT: {
                try {
                    List l = new ArrayList(crs.size());
                    for (int i = 0; i < crs.size(); i++) l.add(null);
                    // WRONG: form = new SimpleForm(n, l);
                } catch(Exception e) { throw parseError("Form build failed: " + e.getMessage()); }
                break;
            }
            case Yoneda.COLIMIT: {
                try {
                    List l = new ArrayList(crs.size());
                    for (int i = 0; i < crs.size(); i++) l.add(null);
                    form = new ColimitForm(n, l);
                } catch(Exception e) { throw parseError("Form build failed: " + e.getMessage()); }
                break;
            }
            case Yoneda.POWER: {
                try {
                    // WRONG:
 		    // form = new SimpleForm(n, null);
                } catch(Exception e) { throw parseError("Form build failed: " + e.getMessage()); }
                break;
            }
            case Yoneda.LIST: {
                try {
                    // WRONG:
                    // form = new SimpleForm(n, null);
                } catch(Exception e) { throw parseError("Form build failed: " + e.getMessage()); }
                break;
            }
            default:
                throw parseError("Illegal space type");
        }
        form.setConnector(crs);
        t.forms().put(name, form);
        return form;
    }


	private Form lookupForm(NameEntry name) {
		Form f = null;
		if (rep != null)
			f = rep.getForm(name);
		if (f == null)
			f = t.forms().get(name);
		return f;
	}
	
	
	private Denotator lookupDenotator(NameEntry name) {
		Denotator d = null;
		if (rep != null)
			d = rep.getDenotator(name);
		if (d == null)
			d = t.ndenos().get(name);
		return d;
	}
	
	
    private Denotator defineDenotator(NameEntry name, Module address, Form form, List cds) 
        throws ParseException {
        try {
            if (name != null && lookupDenotator(name) != null)
                throw parseError("Denotator '" + name + "' already defined.");

            Denotator deno = null;
            if (name != null) {
	        // WRONG:
                // deno = new Denotator(Naming.getNameDenotator(name), address, form, cds);
                t.ndenos().put(name, deno);
            }
            else {
                // WRONG:
                // deno = new Denotator(null, address, form, cds);
                t.adenos().add(deno);
            }
            return deno;
        } 
        catch(Exception e) { 
        	throw parseError("Denotator construction failed: " + e.getMessage());
        }
    }

    /*
     * $$$RA: this should be moved somewhere else
     */
    private Module makeModule(String s, int sub, int sup) throws ParseException {
        // RA: ZASCII ist maintained here for backward compability
        if (s.equals("ZString") || s.equals("ZASCII")) {
            if (sup != -1) throw parseError("Illegal module '" + s + "^n'");
            if (sub == -1)   return ZStringRing.ring;
            else            return ZnStringRing.make(sub);
        }
        else if (s.equals("QString")) {
            if (sub != -1) throw parseError("Illegal module '" + s + "_n'");
            if (sup != -1) throw parseError("Illegal module '" + s + "^n'");
            return QStringRing.ring;
        }
        else if (s.equals("RString")) {
            if (sub != -1) throw parseError("Illegal module '" + s + "_n'");
            if (sup != -1) throw parseError("Illegal module '" + s + "^n'");
            return RStringRing.ring;
        }
        else if (s.equals("Z")) {
            if (sup == -1) {
                if (sub == -1)   return ZRing.ring;
                else            return ZnRing.make(sub);
            }
            else {
                if (sub == -1)   return ZProperFreeModule.make(sup);
                else            return ZnProperFreeModule.make(sup, sub);
            }
        }
        else if (s.equals("Q")) {
            if (sub != -1) throw parseError("Illegal module '" + s + "_n'");
            if (sup == -1)       return QRing.ring;
            else                return QProperFreeModule.make(sup);
        }
        else if (s.equals("R")) {
            if (sub != -1) throw parseError("Illegal module '" + s + "_n'");
            if (sup == -1)       return RRing.ring;
            else                return RProperFreeModule.make(sup);
        }
        else if (s.equals("C")) {
            if (sub != -1) throw parseError("Illegal module '" + s + "_n'");
            if (sup == -1)       return CRing.ring;
            else                return CProperFreeModule.make(sup);
        }
        else if (s.equals("Null")) {
            return ZProperFreeModule.nullModule;
        }
        throw parseError("Illegal module '" + s + "'");
    }

    private boolean isBasicType(String s) {
        if (s.equals("ZString") ||
           s.equals("ZASCII") || 
           s.equals("QString") || 
           s.equals("RString") || 
           s.equals("Z") || 
           s.equals("Q") || 
           s.equals("R") ||
           s.equals("Null")) 
           return true;
        else 
        	return false;
    }
    
    private void beginNamespace(NameEntry name) {
    	if (namespace.size() > 0) {
    		NameEntry ne = (NameEntry)namespace.getFirst();
    		namespace.addFirst(NameEntry.lookup(NameEntry.concat(ne, name)));
    	}
    	else {
    		namespace.addFirst(name);
    	}
    }
        
    private void endNamespace() {
    	namespace.removeFirst();
    }
        
    private NameEntry getCurrentNamespace() {
    	if (namespace.size() > 0)
    		return (NameEntry)namespace.getFirst();
    	else
    		return null;
    }
	
	private NameEntry getNSName(NameEntry name) {
		if (name == null)
			return null;
		else {
			NameEntry ns = getCurrentNamespace();
			if (ns != null)
				return NameEntry.lookup(NameEntry.concat(ns, name));
			else
				return name;
		}
	}


    // private attributes
    
    private Symboltable t;
    private URL url;
    private Repository rep;
    private LinkedList namespace = new LinkedList();
}

PARSER_END(DenotexParser)


////////////////////////////////////////////////////////////////////////////////
//////////////////// LEXICAL DEFINITIONS ///////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

SKIP : {
    " "
|   "\t"
|   "\n"
|   "\r"
|   <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
|   <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}

TOKEN : {
   <INTEGER_LITERAL: ["0"-"9"] (["0"-"9"])*>
|  <FLOATING_POINT_LITERAL: (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? | "." (["0"-"9"])+ (<EXPONENT>)? | (["0"-"9"])+ <EXPONENT> >
|  <#EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+>
|  <STRING_LITERAL: "\"" (~["\"","\\","\n","\r"] | "\\" (["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])? | ["0"-"3"] ["0"-"7"] ["0"-"7"]))* "\"">
}

TOKEN [IGNORE_CASE]: {
    <INCLUDE:   "#include">
|   <BEGIN:     "&begin">
|   <END:       "&end">
|   <FORM:      "form">
|   <SUBSTANCE: "substance">
|   <MODULE:    "module">
|   <NAMESPACE: "namespace">
|   <SYN_O:     "<|">
|   <SYN_C:     "|>">
|   <LIST_O:    "<<">
|   <LIST_C:    ">>">
}

TOKEN : {
   <IDENTIFIER: <LETTER> (<LETTER> | <DIGIT>)*>
|  <QIDENTIFIER: "'" (<LETTER> | <DIGIT> | "_" | "+" | "-" | "*")* "'">
|  <#LETTER: ["A"-"Z","a"-"z"]>
|  <#DIGIT: ["0"-"9"]>
}



////////////////////////////////////////////////////////////////////////////////
//////////////////// GRAMMAR DEFINITIONS ///////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

void denotex() : {}
{
    ( includeCommand() | definitionBlock() )*
}



////////////////////////////////////////////////////////////////////////////////
//////////////////// INCLUDE FILE //////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

void includeCommand() : 
{ 
    Token t; 
}
{
    <INCLUDE> t = <STRING_LITERAL>
    { 
    	includeFile(stripQuotes(t.image));
    }
}



////////////////////////////////////////////////////////////////////////////////
//////////////////// DEFINITION BLOCK //////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

void definitionBlock() : 
{
    NameEntry name;
}
{
    LOOKAHEAD(3) ( <BEGIN> "(" <FORM> ")" ";" ( formDefinition()  ";" )* <END> "(" <FORM> ")" ";" )
|   LOOKAHEAD(3) ( <BEGIN> "(" <SUBSTANCE> ")" ";" ( substanceDefinition() ";" )* <END> "(" <SUBSTANCE> ")" ";" )
|   LOOKAHEAD(3) ( <BEGIN> "(" <MODULE> ")" ";" ( moduleDefinition() ";" )* <END> "(" <MODULE> ")" ";" )
|   LOOKAHEAD(3) ( <BEGIN> "(" <NAMESPACE> "," name = nameSpaceName() ")" ";" 
				   { beginNamespace(name); }
                   ( definitionBlock() )*
                   <END> "(" <NAMESPACE> ")" ";" 
                   { endNamespace(); }
                 )
}


NameEntry nameSpaceName() :
{
    NameEntry name = new NameEntry();
    String sname;
}
{
    sname = id() 
    { name.add(sname); }
    ( "/" sname = id() { name.add(sname); })*
    { 
    	return name;
	}
}
	


////////////////////////////////////////////////////////////////////////////////
//////////////////// FORM DEFINITIONS //////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

void formDefinition() : 
{
    NameEntry name; // form name
    int type;       // space type
    List clist;     // coordinator list
}
{
    name = formName() ":" ( morphism() )? "." type = spaceType() clist = crs(type)
    { 
    	defineForm(name, type, clist);
    }
}


List crs(int type) : 
{
    List clist;     // coordinator list
}
{
(
    clist = simpleCrs(type)
|   clist = limitCrs(type)
|   clist = colimitCrs(type)
|   clist = powerCrs(type)
|   clist = listCrs(type) 
)   
    { return clist; }
}


List simpleCrs(int type) : 
{
    checkDelimiters(Yoneda.SIMPLE, type);
    List c = new ArrayList(1);
    Module m;
    ModuleElement lo = null;
    ModuleElement hi = null;
}
{
    "(" m = module() ( "," lo = moduleElement(m) "," hi = moduleElement(m) )? ")"
    {
        c.add(m);
        c.add(lo);
        c.add(hi);
        return c;
    }
}


List limitCrs(int type) :
{
    checkDelimiters(Yoneda.LIMIT, type);
    List names;
}
{
    "[" names = formNameList() "]"
    { return names; }
}


List colimitCrs(int type) :
{
    checkDelimiters(Yoneda.COLIMIT, type);
    List names;
}
{
    "<" names = formNameList() ">"
    { return names; }
}


List powerCrs(int type) :
{
    checkDelimiters(Yoneda.POWER, type);
    List names = new ArrayList(1);
    NameEntry name;
}
{
    "{" name = formName() "}"
    {
        names.add(name);
        return names;
    }
}


List listCrs(int type) :
{
    checkDelimiters(Yoneda.LIST, type);
    List names = new ArrayList(1);
    NameEntry name;
}
{
    <LIST_O> name = formName() <LIST_C>
    { 
        names.add(name);
        return names; 
    }
}


List formNameList() : 
{
    List names = new ArrayList();
    NameEntry name;
}
{
    name = formName() { names.add(name); } ( ","  name = formName() { names.add(name); } )*
    {
    	return names;
    }
}


NameEntry formName() :
{
    NameEntry name = new NameEntry();
    String sname;
    boolean root = false;
}
{
	( "/" { root = true; } )?
    sname = id() 
    { name.add(sname); }
    ( "/" sname = id() { name.add(sname); })*
    { 
    	if (root) {
		    return NameEntry.lookup(name); 
		}
		else {
			return getNSName(name);
		}
	}
}


int spaceType() : 
{
    String type;
}
{
    type = id()
    {
        try {
            return Form.stringToType(type);
        }
        catch(Exception e) {
            throw parseError("Illegal space type '" + type + "'");
        }
    }
}


void morphism() : {}
{
    id()
    {
        throw parseError("Morphisms not supported yet");
    }
}


void diagram() : {}
{
    id()
    {
        throw parseError("Diagrams not supported yet");
    }
}



////////////////////////////////////////////////////////////////////////////////
//////////////////// DENOTATOR DEFINITIONS /////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

void substanceDefinition() : 
{
    NameEntry name = null;
}
{
    ( name = denotatorName() )? ":" denotatorDefinition(name, null, null)
}


Denotator denotatorDefinition(NameEntry name, Module expectedAddress, Form expectedForm) : 
{
    Module a;          // address
    NameEntry fname;   // form name
    Form f;            // form
    List c;            // coordinate list
}
{
    a = address() "@" fname = formName()
    {
        if (expectedAddress != null && expectedAddress.compareTo(a) != 0)
            throw parseError("Expected address " + expectedAddress +
            			     ", got address " + a);

        f = lookupForm(fname);
        if (f == null)
            throw parseError("Form '" + fname + "' not defined.");
        if (expectedForm != null && !expectedForm.equals(f))
            throw parseError("Expected form '" + expectedForm.getNameString() +
            				 "', got form '" + f.getNameString() + "'");

        try {
            Linker.link(f, t, rep);
        }
        catch(Exception e) {
            throw parseError("Form '" + f + "' could not be linked: " + e.getMessage());
        }
    }
    c = cds(a, f)
    {
    	return defineDenotator(name, a, f, c);
    }
}


Module address() :
{
    Module a = null;
}
{
    ( a = module() )?
    {
        if (a == null)
            a = ZProperFreeModule.nullModule;
        return a;
    }
}


List cds(Module address, Form form) :
{
    List l;
}
{
	(
    	l = simpleCds(address, form) 
	|  	l = limitCds(address, form)
	|   l = colimitCds(address, form)
	|   l = powerCds(address, form)
	|   l = listCds(address, form)
	)
    {
    	return l;
    }
}


List simpleCds(Module address, Form form) : 
{
    checkDelimiters(Yoneda.SIMPLE, form.getType());
    Module m = form.getIdentifier().getCodomainModule();
    List c = new ArrayList(1);
    ModuleElement e;
}
{
    "(" e = moduleElement(m) ")"
    { 
        c.add(e);
        return c;
    }
}

List limitCds(Module address, Form form) :
{
    checkDelimiters(Yoneda.LIMIT, form.getType());
    FormDiagram diag = (FormDiagram)form.getIdentifier().getCodomainDiagram();
    List c = new ArrayList();
    Denotator d;
    int index = 0;
}
{
    "[" 
    {
        if (index >= diag.getFormCount())
            throw parseError("Too many elements in limit: " + index);
    }
    d = denotator(address, diag.getForm(index++)) 
    { c.add(d); } 
    ( 
        ","  
        {
            if (index >= diag.getFormCount())
                throw parseError("Too many elements in limit: " + index);
        }
        d = denotator(address, diag.getForm(index++)) 
        { c.add(d); } 
    )* 
    "]" 
    {
    	if (index < diag.getFormCount())
    		throw parseError("Not enough elements in limit: " + index);
    	return c;
    }
}


List colimitCds(Module address, Form form) :
{
    checkDelimiters(Yoneda.COLIMIT, form.getType());
    FormDiagram diag = (FormDiagram)form.getIdentifier().getCodomainDiagram();
    List c = new ArrayList(2);
    Token p;
    Denotator d;
}
{
    "<" p = <INTEGER_LITERAL>
    {
        int index = Integer.parseInt(p.image);
        if (index < 0 || index >= diag.getFormCount())
            throw parseError("Colimit index out of range: " + index);
    }
    "," d = denotator(address, diag.getForm(index)) ">"
    {
        c.add(new Integer(index));
        c.add(d);
        return c;
    }
}


List powerCds(Module address, Form form) :
{
    checkDelimiters(Yoneda.POWER, form.getType());
    FormDiagram diag = (FormDiagram)form.getIdentifier().getCodomainDiagram();
    Form ff = diag.getForm(0);
    List c = new ArrayList();
    Denotator d;
}
{
    "{"
    	( d = denotator(address, ff) { c.add(d); } 
    	( ","  d = denotator(address, ff) { c.add(d); } )* )?
    "}"
    {
    	return c;
    }
}


List listCds(Module address, Form form) :
{
    checkDelimiters(Yoneda.LIST, form.getType());
    FormDiagram diag = (FormDiagram)form.getIdentifier().getCodomainDiagram();
    Form ff = diag.getForm(0);
    List c = new ArrayList();
    Denotator d;
}
{
    <LIST_O>
    	( d = denotator(address, ff) { c.add(d); } 
    	( ","  d = denotator(address, ff) { c.add(d); } )* )?
    <LIST_C>
    {
    	return c;
    }
}


Denotator denotator(Module address, Form form) :
{
    Denotator d = null;
    NameEntry name;
}
{
    LOOKAHEAD(2)
    name = denotatorName() ( ":" d = denotatorDefinition(name, address, form) )?
    {
        if (d == null) {
            d = lookupDenotator(name);
            // $$$RA 030129: significant change: allow undefined denos
            if (d == null) {
                // WRONG:
                // d = new Denotator(NameDenotator.make(name), form);
                d.setConnector(name);
            }
            else {
                if (address.compareTo(d.getAddress()) != 0)
                    throw parseError("Expected address " + address +
                                     ", got address " + d.getAddress());
            }
        }
        return d;
    }
|   LOOKAHEAD(2)
	d = denotatorDefinition(null, address, form)
	{
		return d;
	}
|   LOOKAHEAD(2)
    { 
	    Module m = form.getIdentifier().getCodomainModule();
    	List c = new ArrayList(1);
		LinkedList elements;		
	}
    elements = basicElement(m)
    { 
        c.add(m.createElement(elements));
        return defineDenotator(null, address, form, c);        
    }		
|   {
		List c;
    }
    c = cds(address, form)
    {
        return defineDenotator(null, address, form, c);
    }
}


NameEntry denotatorName() : 
{
    NameEntry name = new NameEntry();
    String sname;
    boolean root = false;
}
{
	( "/" { root = true; } )?
    sname = id() 
    { name.add(sname); }
    ( "/" sname = id() { name.add(sname); })*
    { 
    	if (root) {
		    return NameEntry.lookup(name); 
		}
		else {
			return getNSName(name);
		}
	}
}



////////////////////////////////////////////////////////////////////////////////
//////////////////// MODULE DEFINITIONS ////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

void moduleDefinition() : 
{
    String n;
    Module m;
}
{
    n = moduleName() ":" m = module()
    {
        if (t.modules().get(n) != null)
            throw parseError("Module '" + n + "' already defined.");
        t.modules().put(n, m);
    }
}


String moduleName() : 
{
    Token t;
}
{
    t = <IDENTIFIER>
    {
    	return t.image;
    }
}


Module module() : 
{
    Module m = null;
}
{
    m = basicModule()
    {
    	return m;
    }
|   {
		List l = new LinkedList();
	}
    "{" 
    	( m = module() { l.add(m); } ( "," m = module() { l.add(m); } )* )?
    "}"
    {
        // WRONG:
    	// return new CompositeModule((Module[])l.toArray(new Module[0]));
        return null;
    }
}


Module basicModule() : 
{
    String n;
    int sub = -1;
    int sup = -1;
}
{
    n = basicType() ( "_" sub=nLiteral() )? ( "^" sup=nLiteral() )?
    {
        if (isBasicType(n))
           return makeModule(n, sub, sup); 
        else {
            if (sub != -1 || sup != -1)
                throw parseError("Sub- or superscript not allowed for module name.");
            Module m = (Module)t.modules().get(n);
            if (m == null) 
                throw parseError("Module '" + n + "' not defined.");
            return m;
        }
    }
}


String basicType() :
{
    Token t;
}
{
    t = <IDENTIFIER>
    { 
    	return t.image; 
    }
}


ModuleElement moduleElement(Module m) : 
{
    LinkedList elements;
}
{
    elements = compositeElement(m)
    {
    	return m.createElement(elements);    
    }
}


LinkedList compositeElement(Module m) :
{
	LinkedList elements = new LinkedList();
	LinkedList newElements;
}
{
    elements = basicElement(m)
    {
    	return elements;
    }
    
|   { int i = 0; }
    "{" 
    (   
        {
            if (i < 0 || i >= m.getDimension())
                throw parseError("Composite module index out of range: " + i);
        }
        elements = compositeElement(m.getComponentModule(i++)) 
        ( 
            "," 
            {
                if (i < 0 || i >= m.getDimension())
                    throw parseError("Composite module index out of range: " + i);
            }
            newElements = compositeElement(m.getComponentModule(i++))
            {
            	elements.addAll(newElements);
            }
        )* 
    )? 
    "}"
    {
        if (i != m.getDimension())
        	throw parseError("Expected " + m.getDimension() + 
        	                 " elements in composite element");
        return elements;
    }
}


LinkedList basicElement(Module m) :
{
	LinkedList elements = new LinkedList();
}
{
    // ZElement, ZpElement, QElement, and, also accepted RElement
    LOOKAHEAD(2) { Rational q; }
    q = qLiteral()
    {
        try {
            int n = q.getNumerator();
            int d = q.getDenominator();
            if (m instanceof ZRing) {
                if (d != 1) throw parseError("");
                elements.add(new ZElement(n));
            }
            else if (m instanceof ZnRing) {
                if (d != 1) throw parseError("");
                elements.add(new ZnElement(n, ((ZnRing)m).getModulus()));
            }
            else if (m instanceof QRing)
            	elements.add(new QElement(q));
            else if (m instanceof RRing)
                elements.add(new RElement((double)n / (double)d));

            // we also allow to convert numbers into strings without quotes
            else if (m instanceof ZStringRing)
                elements.add(new ZStringElement("" + (double)n / (double)d));
            else if (m instanceof ZnStringRing)
                elements.add(new ZnStringElement("" + (double)n / (double)d, 
                                            ((ZnStringRing)m).getModulus()));
            else if (m instanceof QStringRing)
                elements.add(new QStringElement("" + (double)n / (double)d));
            else if (m instanceof RStringRing)
                elements.add(new RStringElement("" + (double)n / (double)d));

            // error
            else throw parseError("");
        } 
        catch(Exception e) {
            throw parseError("Expected element from " + m.toString());
        }
        return elements;
    }
    
|   // RElement
    LOOKAHEAD(2) { double r; }
    r = rLiteral()
    {
        try {
            if (m instanceof RRing)
                elements.add(new RElement(r));

            // we also allow to convert numbers into strings without quotes
            else if (m instanceof ZStringRing)
                elements.add(new ZStringElement("" + r));
            else if (m instanceof ZnStringRing)
                elements.add(new ZnStringElement("" + r, ((ZnStringRing)m).getModulus()));
            else if (m instanceof QStringRing)
                elements.add(new QStringElement("" + r));
            else if (m instanceof RStringRing)
                elements.add(new RStringElement("" + r));

            // error
            else throw parseError("");
        }
        catch(Exception e) {
            throw parseError("Expected element from " + m.toString());
        }
        return elements;
    }
    
|   // CElement
    LOOKAHEAD(2) { Complex c; }
    c = cLiteral()
    {
    	try {
    		if (m instanceof CRing)
    			elements.add(new CElement(c));
    		else
    			throw parseError("");
    	}
    	catch (Exception e) {
    		throw parseError("Expected element from " + m.toString());
    	}
    	return elements;
    }

|   // ZString, ZpString, QString or RString
    { String s; }
    s = sLiteral()
    {
        try {
            if (m instanceof ZStringRing)
                elements.add(new ZStringElement(s));
            else if (m instanceof ZnStringRing)
                elements.add(new ZnStringElement(s, ((ZnStringRing)m).getModulus()));
            else if (m instanceof QStringRing)
                elements.add(new QStringElement(s));
            else if (m instanceof RStringRing)
                elements.add(new RStringElement(s));

            // error
            else throw parseError("Expected StringElement, got " + s);
        } catch(Exception e) {
            e.printStackTrace();
            throw parseError("Expected element from " + m.toString());
        }
        return elements;
    }
}



////////////////////////////////////////////////////////////////////////////////
//////////////////// LITERALS AND VALUES  //////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

String id() : 
{
    Token n;
}
{
    n = <IDENTIFIER>
    {
    	return n.image;
    }
|   n = <QIDENTIFIER>
    {
    	return stripQuotes(n.image);
    }
}


int nLiteral() : 
{
    Token t;
}
{
    t = <INTEGER_LITERAL>
    {
    	return Integer.parseInt(t.image);
    }
}


int zLiteral() : 
{
    int n;
}
{
    ( "+" )? n = nLiteral()
    {
    	return n;
    }
|   "-" n = nLiteral()
    {
    	return -n;
    }
}


Rational qLiteral() : 
{
    int n;
    int d = 1;
}
{
    n = zLiteral() ( "/" d=zLiteral() )?
    {
    	return new Rational(n, d);
    }
}


double rLiteral() : 
{
    Token t;
}
{
    ( "+" )? t = <FLOATING_POINT_LITERAL>
    {
    	return Double.parseDouble(t.image);
    }
|   "-" t = <FLOATING_POINT_LITERAL>
    {
    	return -Double.parseDouble(t.image);
    }
}


Complex cLiteral() : 
{
    double r = 0.0;
    double i = 0.0;
}
{
	r = rLiteral() "+" "i" ("*")? i = rLiteral()
	{
		return new Complex(r, i);
	}
}


String sLiteral() : 
{
    Token t;
}
{
    t = <STRING_LITERAL>
    {
    	return stripQuotes(t.image);
    }
}
